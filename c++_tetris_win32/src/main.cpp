
#include <GL/glut.h>
#include <stdlib.h>
#include <string.h>

#include "Render.h"
#include "Action.h"
#include "BlockModel.h"

//game screen
#define screen_width 800
#define screen_height 600

//Render object
Render paint;

//Action object
Action game_action;

//BlockModel object and varriables
BlockModel blocks;
int rotation_number = 0;
int random_block = 0;
bool can_rotate = false;

//game general varriables
#define n_map_width 10
#define n_map_height 20

//scores
int scores = 0;




void rotate_exception();

//------------------------------------------------------------------------------

void renderBitmapString(float x, float y, float z ,void *font, char *string) {  
  char *c;
  glRasterPos3f(x,y, z);
  for (c=string; *c != '\0'; c++){
    glutBitmapCharacter(font, *c);
  }
}

//------------------------------------------------------------------------------


void draw_scores(){
     
     char scores_text[50];
     
     memset( & scores_text[0], 0 , sizeof(scores_text) ); //clear score_text string variable
     strcat(scores_text, "Scores : ");
     char number_text[20];
     itoa(scores, number_text, 10); // convert integer to char array
     strcat(scores_text, number_text);   
     
     //glut print text on screen
     glColor3f(1,0,1);
     renderBitmapString(100, 300, 0 , GLUT_BITMAP_8_BY_13, scores_text);  
     
          
     
}



//------------------------------------------------------------------------------

void render(){
     
     
     game_action.check_game_over();
     scores = game_action.line_burn_scores;
     rotate_exception();     
     
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); 

    //init drawing cordinates 
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0, screen_width, screen_height, 0, -1, 1);
    
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
      
     
     //--------------------
     //drawLine();
     
      random_block = game_action.falling_block_index;
     
     paint.drawField();
     paint.drawAllBlocks(game_action.field);
     
     if( ! game_action.game_over ) {
     
         //paint.drawFallingBlock(  game_action.block_fall_x , game_action.block_fall_y, 1 );
     
         //int random_block = 1; // values from 0 to 6 ( 7 diffrent block generated by random )
     
         //draw falling block -> render all 4 small blocks
         for(int i = 0; i < 4; i++ ){
            int x = blocks.tetris_bricks[random_block][rotation_number][i][0];
            int y = blocks.tetris_bricks[random_block][rotation_number][i][1];
            paint.drawFallingBlock(  game_action.block_fall_x + x , game_action.block_fall_y + y, random_block );       
            }
     
     
     
            paint.drawGameOverArea( game_action.block_start_fall_x, game_action.block_start_fall_y );
     
     
            //glColor3f(1,0,1);
           // char * s_all = "Hello text !";
            //renderBitmapString(100, 100, 0 , GLUT_BITMAP_8_BY_13, s_all);
     
            char * can_rotate_text;
     
            if( can_rotate){
                can_rotate_text = "Block can be rotated ! ";
            }
            else if( ! can_rotate){
                  can_rotate_text = "Block can't be rotated ! ";
            }
     
            glColor3f(1,0,1);
            renderBitmapString(100, 100, 0 , GLUT_BITMAP_8_BY_13, can_rotate_text);
     
     
     }
     
     
     
     if(game_action.game_over){
     
            glColor3f(1,0,1);
            char * s_all = "GAME OVER !";
            renderBitmapString(100, 200, 0 , GLUT_BITMAP_8_BY_13, s_all);
                   
     }
     
     draw_scores();
     
     //---------------------
     glutSwapBuffers();
     
     
    
     if( ! game_action.game_over){
     //limit block fall by time for falling speed
             if(game_action.delay_counter > game_action.delay ){ 
      
             int x[4], y[4];
      
             for(int i = 0; i < 4; i++){
                     x[i] = blocks.tetris_bricks[random_block][rotation_number][i][0];
                     y[i] = blocks.tetris_bricks[random_block][rotation_number][i][1];
                     }
       
                     game_action.block_fall(x, y, can_rotate);
      
                     game_action.delay_counter = 0; 
             }
      
             //burn lines with no space + burned lines fall
             game_action.lines_burn();
      
      
      
             //count falling time
             game_action.tick();
    }
   
    glutPostRedisplay();



}


//------------------------------------------------------------------------------

void game_init(){
     
     //init render values
     paint.field_start_x = 300;
     paint.field_start_y = 100;
     
     paint.cell_width = 20;
     paint.cell_height = 20;
     
     paint.map_width = 10;
     paint.map_height = 20;
     
   
     
     //init action values
     game_action.game_over = false;
     game_action.line_burn_scores = scores;
     
     game_action.delay = 25;
     game_action.delay_counter = 0;
     
     
     game_action.block_start_fall_x = 3; //new block begin fall from this cordinates
     game_action.block_start_fall_y = 0; 
     game_action.block_fall_x = game_action.block_start_fall_x;
     game_action.block_fall_y = game_action.block_start_fall_y;
     
     game_action.map_width = n_map_width;
     game_action.map_height = n_map_height;
     
     game_action.falling_block_index = game_action.randomize_new_block(); // generate new falling block
     
     
     
       //init empty map
      for(int j = 0; j < n_map_height; j++){
         for(int i = 0; i < n_map_width; i++){
              game_action.field[j * n_map_width + i] = 0;      
         }        
      }
     
     
     //init BlockModel
     blocks.init_block_values();
     
     
      //paint.drawAllBlocks(game_action.field);
    

     
     }

//------------------------------------------------------------------------------
//check overflow over right border
void rotate_exception(){
     
     can_rotate = false;
     int block_can_rotate = 0;
     
     //check next rotation block -> to allow rotate block
     int ch_rotation_number = rotation_number + 1;
     if(ch_rotation_number == 4) ch_rotation_number = 0;
     
     for(int i = 0; i < 4; i++){
             int x = blocks.tetris_bricks[random_block][ch_rotation_number][i][0];
             
             if( (game_action.block_fall_x + x ) > game_action.map_width - 1 ) can_rotate = false;
             else block_can_rotate++;
                    
     }
     //all falling blocks are rotatable
     if(block_can_rotate == 4 ) can_rotate = true;
     
          
}

//------------------------------------------------------------------------------

void keyboard_control(int key, int x, int y){
    
    int can_move_block;
    
     switch(key) {
        
        case GLUT_KEY_RIGHT :
             
             can_move_block = 0;
             
             for(int i = 0; i < 4; i++){
                     int x = blocks.tetris_bricks[random_block][rotation_number][i][0];
                if( (game_action.block_fall_x + x) < game_action.map_width - 1) can_move_block ++;
             } 
             
             if(can_move_block == 4)game_action.move_right();
        break;
        
        case GLUT_KEY_LEFT :
             game_action.move_left();
        break;
        
        
        case GLUT_KEY_UP :
             
             rotate_exception();
             //rotate_exception here -> for checking block overflow from field
             if( can_rotate ){
                 rotation_number +=1;
                 if(rotation_number == 4) rotation_number = 0;    
             }
                   
        break;
        
        case GLUT_KEY_DOWN :
             game_action.delay_counter = game_action.delay; //speed up block falling
        break;           
     
     }     
}


//------------------------------------------------------------------------------


int main(int argc, char *argv[]){
    
    game_init();
    
    glutInit(&argc, argv);
    glutInitWindowSize(screen_width,screen_height);
    glutInitWindowPosition(10,10);
    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);

    //glutReshapeFunc(resize);

    glutCreateWindow("Tetris public version 1 by Stanislav Savolainen");
    
    
    glutDisplayFunc (render); // render() function looped
    //glutIdleFunc(game_action.tick);
    glutSpecialFunc(keyboard_control);
    glutMainLoop();
    
      
    return 0;
    }
